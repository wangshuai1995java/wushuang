# mysql索引的数据结构

MyISAM是MySQL5.5之前版本默认的存储引擎,从5.5之后,InnoDB

开始成为MySQL的默认存储引擎.

前者是使用B-tree实现了主键索引,唯一索引,非主键索引

后者中的非主键索引使用的是B-tree数据结构,而主键索引使用的是B+tree

## B-Tree

b-tree不是B减树,而是B树;

一颗m阶的B树,或者为空树,或者需要满足以下特性:

* 树中的每一个结点至多有m棵子树

* 若根节点不是叶子结点,则至少有两棵子树

* 除根节点之外的所有非终端结点至少有m/2棵子树

* 所有非终端结点中包含下列信息数据(n,A0,K1,A1,K2,A2,...Kn,An),其中n代表关键字数目,K(i)为关键字,且K(i)<K(i+1),Ai为指向子树根节点的指针,且指针A(i-1)所指子树中所有结点的关键字均小于Ki,Ai所指向子树中的所有节点的关键字均大于Ki

* 所有叶子结点都出现在同一层次上

  ![1570604868805](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1570604868805.png)

  假如在该图中查找关键字47，首先从根结点开始，根据根结点指针t找到*a结点，因为47大于 *a 结点的关键字35，所以会去A1指针指向的 *c结点继续寻找，因为 *c的关键字 43 < 要查找的47 < *c结点的关键字78，所以去 *c结点A1指针指向的 *g结点去寻找，结果在 *g结点中找到了关键字47，查找成功。

  ##　Ｂ+Tree

  不同的存储引擎就可能使用不用的数据结构存储.InnoDB使用的是B+Tree.

  B加树是应文件系统所需而出的一种B树的变形树,一一棵m阶的B加树与B树的差异在于:

  * **有n棵子树的结点含有n个关键字**
  * 所有的叶子节点中包含了全部的关键字信息,及指向含这些关键字信息的记录的指针,且叶子结点本身依关键字的大小自小而大顺序链接
  * 所有的非终端结点可以看成是索引部分,结点中仅含有其子树(根节点)中最大(或最小)关键字

![1570608025486](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1570608025486.png)

## 为什么使用树结构作为索引?

* 链表的查询效率是O(n),效率较低
* 数组+二分查找的效率是O(lgn),查询快,但是数组插入和删除的速率很低
* 在选择数据库索引的结构的时候，要考虑到另一个问题。索引是存在于磁盘中，当索引非常大的时候，达到几个G的时候，无法一次加载到内存中。考虑到上面两个因素，数据库中索引使用的是树形结构

## 为什么平衡二叉树不适合作为索引

**索引是存在于索引文件当中,是存在于磁盘中的**,因为索引通常是很大的,因此无法一次性将全部的索引**加载到内存当中**,因此每次只能从磁盘中读取一个磁盘页的索引数据到内存中.而这个磁盘的读取速度差内存读取速度好几个级别.

在我们在这说的是平衡二叉树,是**逻辑上的平衡二叉树,其物理是实现是数组.然后由于在逻辑上相近的结点在物理结构上可能回相差很远**.因此.每次读取磁盘页的数据有很多是用不上的,**查找过程中要进行多次的磁盘读取操作.**

适合作为索引的结构应该是尽可能少的执行磁盘IO操作

## B-Tree适合作为索引!

B树充分利用了磁盘预读功能,由此创建的一种数据结构,B树就是为了作为索引才被发明出来的

#### 局部性原理与磁盘预读

由于存储介质的特性,磁盘本身存取就比主存慢很多.再加上机械运动耗费,磁盘的存取速度往往是主存的几百分之一,因此为了提高效率,需要尽量的减少磁盘的IO操作.为了达到这个目的,磁盘往往不是严格的按需读取,而是每次都会**预读,即使只需要一个字节,磁盘也会从这个位置开始.顺序向后读取一定长度的数据放入内存**,这样做的理论依据是计算机科学中著名的**局部性原理**:

**当一个数据被使用时,其附近的数据也通常会马上被使用.**

程序运行期间做需要的数据通常比较集中.由于磁盘顺序读取的效率很高(不需要寻道时间,只需很少的旋转时间),因此对于具有局部性的程序来说,预读可以提高IO效率

### 为什么说红黑树没有充分利用预读功能?

红黑树这种结构,H明显深很多,由于**逻辑上很近的结点(父子)物理上可能很远,无法利用局部性**,也就是说红黑树(平衡二叉树)每次预读可能是预读了很多用不上的数据.**又由于深度大(相对与B树而言),所以进行的磁盘IO操作更多**.

B树的每个节点可以存储多个关键字,他将结点大小设置为磁盘页的大小,充分利用了磁盘预读的功能.每次读取磁盘页时,就会读取一整个结点.也正是因为每个结点存储着非常多个关键字,树的深度就会非常小.进而要执行的磁盘读取操作次数就会非常少,更多的是在内存中对读取进来的数据进行查询.

B树的查询.主要发生在内存中,而平衡二叉树的查询,则是发生在磁盘读取中.因此,虽然B树查询的次数不比二叉树少,但是相比磁盘IO速度,内存中查询的耗时就可以忽略不计.因此,B树更适合作为索引.

## 比B树更适合作为索引的结构B+树

比B树更适合作为索引的结构是B+树,MySQL中也是使用B+树作为索引.它是B树的变种,因此是基于B树来改进的.

**B树 = 有序数组+平衡多叉树**

**B+树 = 有序数组链表+平衡多叉树**

B+树的关键字全部存放在叶子节点这种,非叶子节点用来做索引,而叶子结点中有一个指针指向下一个叶子节点.做这个优化的目的是为了提高区间访问的性能.而正是这个特性决定了B+树更适合用来存储外部数据.

引用搜索引擎作者梁斌老师的话:

**B+树还有一个最大的好处,方便扫库,B树必须用中序遍历的方法按序扫库.而B+树直接从叶子节点挨个扫一遍就完事了,B+树支持range-query非常方便,而B树不支持.这是数据库选用B+树的最主要原因.**

**比如要查5-10之间的,B+树一把到5这个标记,再一把到10,然后串起来就行了,B树就非常麻烦.B树的好处就是查询成功特别有利,因为树的高度总体比B+树矮.不成功的情况下,B树也比B+树稍微占一点点便宜.**

**B树比如你的例子中查17的话,一把就得到了结果,有很多基于频率的搜索就是选用B树,越频繁的query的结点越往根上走,前提是需要对query做统计.而且要对key做一些变化.**

**另外B树也好B+树也好,根或者上面几层因为被反复query,所以这几块基本都在内存中,不会出现读磁盘IO,一般一经启动,就主动换入内存.**

数据库采用B+树的主要原因是**B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题.**正式为了解决这个问题,B+树应用而生.B+树只要遍历叶子节点就可实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的,而B树不支持这样的操作.





