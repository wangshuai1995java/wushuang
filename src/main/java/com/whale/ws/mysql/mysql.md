# mysql索引的数据结构

## 物理磁盘知识

### 基本概念

#### 盘片

硬盘中一般会有多个盘片组成,盘片一般用铝合金材料做基片,硬盘的盘片组在2-14片不等,通常有2-3个盘片

#### 盘面

每一个有效盘面都有一个对应的读写磁头,作用就是将存储在硬盘盘片上的磁信息转化为电信号向外传输.

工作原理则是利用**特殊材料的电阻值会随着磁场变化的原理来读写盘片上的数据.**磁头是用线圈缠绕在磁芯上制成的.**硬盘在工作时,磁头通过感应旋转的盘片上磁场的变化来读取数据,通过改变盘片上的磁场来写入数据**.为了避免磁头和盘片的磨损.在工作状态时,磁头悬浮在高速转动的盘片上方,而不与盘片直接接触,只有在关闭电源之后,磁头会自动回到在盘片上的固定位置(成为着陆区,此处盘片并不存储数据,是盘片的起始位置)

#### 磁道

当磁盘旋转时.磁头若保持在一个位置上,则每个磁头都会在磁盘表面划出一个圆形轨迹,这些圆形轨迹就叫做磁道.

磁盘在格式化时,盘面被划分为多个同心圆,这些同心圆轨迹叫做磁道,而磁带的磁道是沿磁带长度方向的直线,这些磁道用肉眼是根本看不到的

磁道从外向内从0开始顺序编号,每一个盘面有300-1024个磁道,新式大容量硬盘每面的磁道数更多,信息以脉冲串的形式记录在这些轨迹中,这些同心圆是不连续记录数据,而是被划分成一段段的圆弧

#### 柱面

所有盘面上的同一磁道(具有相同编号磁道)构成一个圆柱,称作柱面.

每个圆柱上的磁头由上而下从0开始编号,数据的读/写按柱面进行,只有在同一柱面所有的磁头全部读/写完毕后磁头才转移到下一柱面

选取磁头只需要通过电子切换即可,而选取柱面必须机械切换,电子切换相当快

#### 扇区

每个磁道被等分为若干个弧段,这些弧段便是硬盘的扇区,扇区是硬盘的最小读写单元

操作系统以扇区形式将信息存储在硬盘上,每个扇区包括512个字节的数据和一些其他信息,一个扇区有两个主要部分:存储数据地点的标识符和存储数据的数据段

标识符就是扇区的头标,包括组成扇区的三维地址的三个数字,盘面号,柱面号,扇区号

数据段可分为数据和保护数据的纠错码

#### 磁盘块/簇

虚拟出来的,块是操作系统中最小的逻辑存储单元,操作系统与磁盘打交道的最小单位是磁盘块.通俗的来讲,在windows下如NTFS等文件系统中叫做簇,在linux下如Ext4等文件系统叫做块(block).每个簇或者块可以包括2,4,8,16...2的n次方的扇区

读取方便:由于扇区的数量比较小,数目众多在寻址时比较困难,所以操作系统就将相邻的扇区组和在一起,形成一颗块,再对块进行整体的操作

分离对底层的依赖:操作系统忽略对底层物理存储结构的设计,通过虚拟出来的磁盘块的概念,在系统中认为块是最小的单位

#### page

操作系统经常与内存打交道的最小单位是页,类似于"块"的概念,都需要一种虚拟的基本单位

### 磁盘容量的计算

存储容量 = 磁头数 * 磁道数 * 每道的扇区数 * 每扇区的字节数

某磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，每条磁道有12个扇区，所以此磁盘的容量为：6 * 7 * 12 * 512 = 258048

### 硬盘中的数据

信息存储在硬盘里,硬盘是由很多的盘片组成,通过盘片表面的磁性物质来存储数据

把盘片放在显微镜下放大,可以看到盘片表面是凹凸不平的,凸起的地方被磁化,代表数据1,凹的地方没有被磁化,代表数字0,因此硬盘可以通过二进制的形式来存储表示文字,图片等信息.

所有的盘片都固定在一个旋转轴上,这个轴即盘片主轴,所有的盘片之间是绝对平行的,在每个盘片的盘面上都有一个磁头,磁头与盘片之间的距离比发丝直径还小

所有的磁头连在一个磁头控制器上,由磁头控制器负责各个磁头的运动,磁头可沿盘片的半径方向移动,实际上是斜切运动,每个磁头同一时刻必须是同轴的,即从正上方往下看,所有磁头任何时候都是重叠的

### 磁盘的读写原理

系统将文件存储到磁盘上,按柱面,磁头,扇区的方式进行,即最先是第一磁道的第一刺头下的所有扇区,然后是同一柱面下的一个磁头..

一个柱面的存储满后就推进到下一个柱面,直到把文件内容全部写入磁盘

系统也以相同的顺序读出数据,读出数据是通过告诉磁盘控制器要读出扇区所在的柱面号,磁头号和扇区号(物理地址)进行

操作系统的读取同理,只是颗粒的更大快操作

# ____________________________________________________________________________________________________________



MyISAM是MySQL5.5之前版本默认的存储引擎,从5.5之后,InnoDB

开始成为MySQL的默认存储引擎.

前者是使用B-tree实现了主键索引,唯一索引,非主键索引

后者中的非主键索引使用的是B-tree数据结构,而主键索引使用的是B+tree

## B-Tree

b-tree不是B减树,而是B树;

一颗m阶的B树,或者为空树,或者需要满足以下特性:

* 树中的每一个结点至多有m棵子树

* 若根节点不是叶子结点,则至少有两棵子树

* 除根节点之外的所有非终端结点至少有m/2棵子树

* 所有非终端结点中包含下列信息数据(n,A0,K1,A1,K2,A2,...Kn,An),其中n代表关键字数目,K(i)为关键字,且K(i)<K(i+1),Ai为指向子树根节点的指针,且指针A(i-1)所指子树中所有结点的关键字均小于Ki,Ai所指向子树中的所有节点的关键字均大于Ki

* 所有叶子结点都出现在同一层次上

![1570778665950](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1570778665950.png)

##　Ｂ+Tree

不同的存储引擎就可能使用不用的数据结构存储.InnoDB使用的是B+Tree.

B加树是应文件系统所需而出的一种B树的变形树,一一棵m阶的B加树与B树的差异在于:

* **有n棵子树的结点含有n个指针**
* 所有的叶子节点中包含了全部的关键字信息,及指向含这些关键字信息的记录的指针,且叶子结点本身依关键字的大小自小而大顺序链接
* 所有的非终端结点可以看成是索引部分,结点中仅含有其子树(根节点)中最大(或最小)关键字

![1570778583900](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1570778583900.png)



## 为什么使用树结构作为索引?

* 链表的查询效率是O(n),效率较低
* 数组+二分查找的效率是O(lgn),查询快,但是数组插入和删除的速率很低
* 在选择数据库索引的结构的时候，要考虑到另一个问题。索引是存在于磁盘中，当索引非常大的时候，达到几个G的时候，无法一次加载到内存中。考虑到上面两个因素，数据库中索引使用的是树形结构

## 为什么平衡二叉树不适合作为索引

**索引是存在于索引文件当中,是存在于磁盘中的**,因为索引通常是很大的,因此无法一次性将全部的索引**加载到内存当中**,因此每次只能从磁盘中读取一个磁盘页的索引数据到内存中.而这个磁盘的读取速度差内存读取速度好几个级别.

在我们在这说的是平衡二叉树,是**逻辑上的平衡二叉树,其物理是实现是数组.然后由于在逻辑上相近的结点在物理结构上可能回相差很远**.因此.每次读取磁盘页的数据有很多是用不上的,**查找过程中要进行多次的磁盘读取操作.**

适合作为索引的结构应该是尽可能少的执行磁盘IO操作

## B-Tree适合作为索引!

B树充分利用了磁盘预读功能,由此创建的一种数据结构,B树就是为了作为索引才被发明出来的

#### 局部性原理与磁盘预读

由于存储介质的特性,磁盘本身存取就比主存慢很多.再加上机械运动耗费,磁盘的存取速度往往是主存的几百分之一,因此为了提高效率,需要尽量的减少磁盘的IO操作.为了达到这个目的,磁盘往往不是严格的按需读取,而是每次都会**预读,即使只需要一个字节,磁盘也会从这个位置开始.顺序向后读取一定长度的数据放入内存**,这样做的理论依据是计算机科学中著名的**局部性原理**:

**当一个数据被使用时,其附近的数据也通常会马上被使用.程序运行期间所需要的数据通常比较集中.由于磁盘顺序读取的效率很高(不需要寻道时间,只需要很少的旋转时间),因此对于具有局部性的程序来说,预读可以提高I/O效率**

程序运行期间做需要的数据通常比较集中.由于磁盘顺序读取的效率很高(不需要寻道时间,只需很少的旋转时间),因此对于具有局部性的程序来说,预读可以提高IO效率

### 为什么说红黑树没有充分利用预读功能?

红黑树这种结构,H明显深很多,由于**逻辑上很近的结点(父子)物理上可能很远,无法利用局部性**,也就是说红黑树(平衡二叉树)每次预读可能是预读了很多用不上的数据.**又由于深度大(相对与B树而言),所以进行的磁盘IO操作更多**.

B树的每个节点可以存储多个关键字,他将结点大小设置为磁盘页的大小,充分利用了磁盘预读的功能.每次读取磁盘页时,就会读取一整个结点.也正是因为每个结点存储着非常多个关键字,树的深度就会非常小.进而要执行的磁盘读取操作次数就会非常少,更多的是在内存中对读取进来的数据进行查询.

B树的查询.主要发生在内存中,而平衡二叉树的查询,则是发生在磁盘读取中.因此,虽然B树查询的次数不比二叉树少,但是相比磁盘IO速度,内存中查询的耗时就可以忽略不计.因此,B树更适合作为索引.

## 比B树更适合作为索引的结构B+树

比B树更适合作为索引的结构是B+树,MySQL中也是使用B+树作为索引.它是B树的变种,因此是基于B树来改进的.

**B树 = 有序数组+平衡多叉树**

**B+树 = 有序数组链表+平衡多叉树**

B+树的关键字全部存放在叶子节点这种,非叶子节点用来做索引,而叶子结点中有一个指针指向下一个叶子节点.做这个优化的目的是为了提高区间访问的性能.而正是这个特性决定了B+树更适合用来存储外部数据.

引用搜索引擎作者梁斌老师的话:

**B+树还有一个最大的好处,方便扫库,B树必须用中序遍历的方法按序扫库.而B+树直接从叶子节点挨个扫一遍就完事了,B+树支持range-query非常方便,而B树不支持.这是数据库选用B+树的最主要原因.**

**比如要查5-10之间的,B+树一把到5这个标记,再一把到10,然后串起来就行了,B树就非常麻烦.B树的好处就是查询成功特别有利,因为树的高度总体比B+树矮.不成功的情况下,B树也比B+树稍微占一点点便宜.**

**B树比如你的例子中查17的话,一把就得到了结果,有很多基于频率的搜索就是选用B树,越频繁的query的结点越往根上走,前提是需要对query做统计.而且要对key做一些变化.**

**另外B树也好B+树也好,根或者上面几层因为被反复query,所以这几块基本都在内存中,不会出现读磁盘IO,一般一经启动,就主动换入内存.**

数据库采用B+树的主要原因是**B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题.**正式为了解决这个问题,B+树应用而生.B+树只要遍历叶子节点就可实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的,而B树不支持这样的操作.







