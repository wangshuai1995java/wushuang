# TCP/IP协议

## 专有名词

SYN:同步序列编号(**Synchronize Sequence Numbers**)。是TCP/IP建立连接时使用的握手信号。

ACK:确认字符(**Acknowledge character**)，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。

ISN:初始化序列号(**Initialization Sequence Number**),TCP初始化序列号不能设置为一个固定值，因为这样容易被攻击者猜出后续序列号，从而遭到攻击。

MSL:在TCP协议中，当发送方发送释放连接报文收到确认报文后，只是在一个方向上断开了TCP连接，然后，接收方发送释放连接的报文，发送方回复确认。此时，连接还没有释放，发送方要等待2MSL（**maximum segment lifetime**——最大的生命周期）后关闭连接.

## 三次握手

三次握手其实就是指建立一个TCP链接时,需要客户端和服务器端总共发送三个包.进行三次握手的主要作用就是确认双方的接收能力和发送能力是否正常,指定自己的初始化序列号为后面的可靠性传送做准备.实质上其实就是连接服务器的指定端口,建立TCP连接,并同步连接双方的序列号和确认号,交换TCP窗口大小信息.

刚开始客户端处于closed的状态,服务端处于Listen状态.

* 第一次握手: 客户端发给服务端一个SYN报文,并指明客户端的初始化序列号ISN©.此时客户端处于SYN_SEND状态.首部的同部位SYN=1,初始序号seq=x,SYN=1的报文段不能携带数据,但要消耗掉一个序号
* 第二次握手:服务器端收到客户端的SYN报文后,会以自己的SYN报文作为应答,并且指定了自己的初始化序列号ISN(s).同时会把客户端的ISN+1作为ACK的值,表示自己已经收到了客户端的SYN,此时服务器端处于SYN_REVD的状态.在确认报文段中SYN=1,ACK=1,确认号ack=x+1,初始序号seq=y.
* 第三次握手:客户端收到SYN报文之后,会发送一个ACK报文,当然,也是一样把服务器的ISN+1作为ACK的值,表示已经收到了服务器的SYN报文,此时客户端处于ESTABLISHED状态.服务器收到ACK报文之后,也处于ESTABLISHED(建立连接)状态,此时双方已经建立起了连接.确认报文段ACK=1,确认号ack=y+1,序号seq=x+1(初始为seq=x,第二个报文段所以要+1),ACK报文段可以携带数据,不携带数据则不消耗序号.

发送第一个SYN的一端将执行主动打开(active open),接收这个SYN并发回下一个SYN的另一端执行被动打开(passive open).在socket编程中,客户端执行connect()时,将触发第三次握手.

![1570784347397](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1570784347397.png)

## 为什么需要三次握手,两次不行吗?

这需要明白三次握手中每一次的目的是什么.

* 第一次握手:客户端发送网络报,服务端收到了.

  结论:客户端的发送能力与服务端的接收能力是正常的

* 第二次握手:服务端发包,客户端收到了

  结论:服务端发送能力与客户端接收能力正常,但是此时服务器并不知道客户端接受能力正常

* 第三次握手:客户端发包,服务端收到了

  结论:服务器明白客户端收到了服务器的第二次握手信息,证明客户端的接收能力是正常的

因此需要三次握手才可以检验出服务端与客户端的接收与发送能力是正常的.

**如果只有两次握手的话:**

如果客户端发送了链接请求,但因连接请求报文丢失而未收到确认,于是客户端再重传一次连接请求.后来收到确认,建立连接,在数据传输完毕后就释放了连接,**客户端总共发送了两个连接请求报文段,其中第一个丢失,第二个到达了服务端.但是第一个丢失的报文段只是在某些网络结点长时间滞留,延误到连接释放以后的某个时间才到达服务端,此时服务端误认为客户端又发出一次新的连接请求,是就像客户端发出确认报文段,同意建立连接**,不采用三次握手的话,只要服务端确认就建立了新的连接,此时客户端忽略服务端发来的确认.也不发送数据,则服务端一直等待客户端发送数据,浪费资源,

## 什么是半连接队列

服务器第一次收到客户端的SYN之后,就会处于SYN_RCVD状态,此时双方还没有完全建立连接,服务器会把此种状态下请求连接放在一个队列里,这个队列就是半连接队列(**服务器第一次收到SYN后的连接请求)**

完成三次握手,建立起连接的又会放在另一个队列里,这就是全连接队列.如果队列满了就可能会出现丢包现象.

关于SYN-ACK重传次数的问题:

**服务器在发送晚SYN-ACK包.如果未收到客户端的确认包,服务就进行首次重传,等待一段时间仍未收到客户端的确认包,进行第二次重传.如果重传次数超过系统规定的最大重传次数,系统将该连接信息从半连接队列中删除.每一次的重传等待时间不一定相同,一般会是指数增长,例如时间间隔为1s,2s,4s,8s...**

## ISN(Initial Sequence Number)是固定的吗

当一端为建立连接而发送它的SYN时,它为连接选择一个初始序号,ISN随时间而变化,因此每个连接都将具有不同的ISN.ISN可以看作是一个32比特的计数器,每4ms加1.这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送,而导致某个连接的一方对它作出错误的解释

三次握手的其中一个重要功能是客户端和服务端交换ISN,以便让对方知道接下来接收数据的时候如何按序列号组装数据.如果ISN是固定的,攻击者很容易猜出后续的确认号.因此ISN是动态生成的

## 三次握手过程中可以携带数据吗

其实在第三次握手的时候,是可以携带数据的.但是第一次第二次握手不可以携带数据

假如第一次握手可以携带数据的话,有人要恶意攻击服务器,那么他每次都在第一次握手中的SYN报文中放入大量的数据.因为攻击者根本就不理服务器的接收与发送能力是否正常,然后疯狂重复发SYN报文的话,这会让服务器花费很多时间,内存空间来接收这些报文.

也就是说,第一次握手不可以携带数据,其中一个简单的原因就是会让服务器更加容易受到攻击.而对于第三次的话,此时客户端已处于**ESTABLISHED** 状态,对于客户端来说,他已经建立了连接,并且也已经知道服务器的接收,发送能力是正常的,所以可以携带数据

## SYN攻击是什么

服务器段的资源分配是在第二次握手时分配的,客户端的资源分配是在第三次握手时分配的,所以服务器容易受到SYN泛洪攻击.SYN攻击就是Client在短时间内伪造大量不存在的IP地址,并向Server不断地发送SYN包,Server则回复确认包,并等待Client确认,由于源地址不存在, 因此Server需要不断的重发至超时,这些伪造的SYN包将长时间占用未连接队列(半连接队列),导致正常的SYN请求因为队列满而被丢弃,从而引起网络拥塞甚至系统瘫痪.SYN攻击是一种典型的DoS/DDoS攻击

检测SYN攻击非常方便,当你在服务器上看到大量半连接状态时,特别是源IP地址是随机的基本上可以断定这是一次SYN攻击,在linux/unix上可以使用系统自带的netstats命令来检测SYN攻击.

**netstat -n -p TCP | grep SYN_RECV**

常见防御SYN攻击的方法有如下几种:

* 缩短超时时间(SYN Timeout)
* 增加最大半连接数
* 过滤网关防护
* SYN cookies技术

# 四次挥手

建立一个连接需要三次握手,而终止一个连接要经过四次握手,这是由于TCP的半关闭造成的.所谓的关闭,其实就是TCP提供了连接的一端在结束它的发送后,还能接收来自另一端数据的能力.

TCP的连接的拆除需要发送四个包,因此称为四次挥手,客户端或服务器均可主动发起挥手动作.

刚开始双方都处于ESTABLISHED状态,假如是客户端先发起的关闭请求,四次挥手的过程如下:

* 第一次挥手:客户端发送一个FIN报文,报文中会指定一个序列号.此时客户端处于FIN_WAIT1状态.

  即发出连接释放报文段(FIN=1,序列号seq=u),并停止再发送数据,主动关闭TCP连接,进入FIN_WAIT1(终止等待1)状态,等待服务端的确认

* 第二次挥手:服务端收到FIN之后,会发送ACK报文,且把客户端的序列号值+1作为ACK报文的系列号值,表明已经收到客户端的报文了.此时服务器端处于CLOSE_WAIT状态.

  即服务端收到释放报文端后,会发出确认报文段(ACK=1,确认号ack=u+1,序号seq=v),服务端进入CLOSE_WAIT(关闭等待)状态,此时的TCP处于半关闭状态,等待服务端发出的连接释放报文段.

* 第三次挥手:如果服务端也想断开连接了,和客户端的第一次挥手一样,发送FIN报文,且指定一个序列号.此时服务端处于LAST_ACK状态.

  即服务端没有要向客户端发出的数据,服务端发出连接释放报文段(FIN=1,ACK=1,序号seq=w,确认号ack=u+1),服务端进入LAST_ACK(最后确认)状态,等待客户端的确认

* 第四次挥手:客户端收到FIN之后,一样发送一个ACK报文作为应答,且把服务端的序列号值+1作为自己ACK报文的序列号值,此时客户端处于TIME_WAIT状态,需呀过一阵子以确保服务器收到自己的ACK报文之后才回进入CLOSED状态,服务端收到ACK报文之后,就处于关闭连接,处于CLOSED状态.

  即客户端收到服务端的连接释放报文段后,对此发出确认报文段(ACK=1,seq=u+1.ack=w+1),客户端进入TIME_WAIT(时间等待)状态.此时TCP未释放掉,需要经过时间等待计时器设置的时间2MSL后,客户端才进入CLOSED状态

收到一个FIN只意味着在这个方向上没有数据流动,客户端执行主动关闭并进入TIME_WAIT是正常的,服务端通常执行被动关闭,不会进入TIME_WAIT状态.

在socket编程中,任何一方执行close()操作即可产生挥手操作.

![1571017978719](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1571017978719.png)

### 挥手为什么需要四次?

因为当服务端收到客户端的SYN连接请求报文后,可以直接发送SYN+ACK报文.其中ACK报文是用来应答的,SYN报文是用来同步的.但是在关闭连接时**.当服务器端收到FIN报文时,很可能并不会立即关闭SOCKET,所以只能先回复一个ACK报文,告诉客户端."你发的FIN报文我收到了".只有等到我服务端所有的报文都发送完了,我才能发送FIN报文,**因此不能一起发送,故需要四次挥手.

### 2MSL等待状态

TIME_WAIT状态也成为2MSL等待状态.每个具体TCP实现必须选择一个报文段最大生存时间MSL(Maximum Segment Lifetime),它是任何报文段被丢弃前在网络内的最长时间.这个时间也是有限的,因为TCP报文段以IP数据报在网络内传输,而**IP数据报则有限制其生存时间的TTL字段.**

对于一个具体实现所给定的MSL值,处理的原则是:当TCP执行一个主动关闭,并发回最后一个ACK,该链接必须在TIME_WAIT状态停留的时间为2倍的MSL.这样可让TCP再次发送最后的ACK以防止这个ACK丢失(另一端超时,并发送最后的FIN).

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间,定义这个连接的插口(客户的IP地址和端口号.服务器的IP地址和端口号)不能再被使用.这个连接只能在2MSL结束后才能再被使用

### 四次挥手释放连接时,等待2MSL的意义?

为了保证客户端在发送最后一个ACK报文段能够到达服务器.因为这个ACK有可能丢失,从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文.服务器惠超市重传这个FIN-ACK,接着客户端再重传一次确认,重新启动时间等待计时器.最后客户端和服务器都能正常关闭.假设客户端不等待2MSL,而是发送完ACK之后直接释放关闭,一但这个ACK丢失,服务器就无法正常的进入关闭连接状态

#### 两个理由:

* 保证客户端发送的最后一个ACK报文能够到达服务端.

  这个ACK报文段有可能丢失,使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认,服务端超时重传FIN+ACK报文段.而客户端可能在2MSL时间内收到这个重传的FIN+ACK报文段,接着客户端重传一次确认,重新启动2MSL计时器,最后客户端和服务端进入到CLOSED状态,若客户端再TIME_WAIT状态不等待一段时间,而是发送完ACK报文段后立即释放连接,则无法收到服务器端重传的FIN+ACK报文段,所以不会再发送一次确认报文段,则服务端无法正常进入到CLOSED状态.

* 防止"已失效的连接请求报文段"出现在本连接中.

  客户端在发送晚最后一个ACK报文段后,在经过2MSL.就可以使本连接持续的时间内所产生的所有报文段都从网络中消失,使下一个新的连接中不会出现这种旧的连接请求报文段

### 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态

理论上,四个报文都发送完毕,就可以直接进入CLOSE状态了,但可能网络是不可靠的,有可能最后一个ACK丢失.所以TIME_WAIT状态就是用来重发可能丢失的ACK报文.

# 总结

![1571021007253](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1571021007253.png)

